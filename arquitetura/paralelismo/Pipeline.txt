a idéia é não deixar nada ocioso, adiantar trabalho:
1 - 1 (1)
2 - 3 (2)
3 - 6 (3)
4 - 10 (4)
5 - 15 (5)...

enquanto o outro vai só de 1 em 1, esse outro modelo consegue fazer mais tasks (valor da direita) em menos tempo (valor da esquerda)

então já que faz menos task por tempo/ciclo, vai precisar de um tempo maior para chegar naquela mesma requisição

isso é pensando de modo geral, vamos pensar unitariamente: 

1 mini task toma 5 processos, ent é necessário 5 de t, o modelo primitivo faz 5 do 1, depois 5 do outro, depois 5 do outro... já esse modelo consegue arrastar 4 deles para trás, reduzindo o tempo total, t1-t1-t1-t1-t1-t2-t2-t2-t2-t2 para t1 - t1/t2 - t1/t2 - t1/t2 - t1/t2 - t2
a quantidade é igual, mas consegui mover para mesmos tempos, sempre pegando do final para manter a lógica de que nunca para, isso reduz o tempo unitário de t2, t3... e obviamente o tempo total